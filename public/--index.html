<script>
    let TAB_INFO;

    const channel = new BroadcastChannel("crashme");

    console.log('started')
    console.log(sessionStorage.getItem('crashme.tab'));
    fetch('/log?prev=' + sessionStorage.getItem('crashme.tab'))

    channel.onmessage = (event) => {
        // Could happen when tab is not in focus and setInterval gets slower
        if (event.data.type === "inactive" && event.data.id === TAB_INFO.id) {
            console.log("I'm not inactive!")
            save();
        }
    }

    function load() {
        const tabsString = window.localStorage.getItem('crashme.tabs') || "{}";
        let tabs = JSON.parse(tabsString);
        return tabs
    }

    function update(callback) {
        let tabs = load();
        tabs = callback(tabs);
        sessionStorage.setItem('crashme.tab', JSON.stringify(TAB_INFO));
        window.localStorage.setItem("crashme.tabs", JSON.stringify(tabs));
    }

    function save() {
        TAB_INFO = {
            id: TAB_INFO?.id || Math.random().toString(36).slice(2, 7),
            createdAt: TAB_INFO?.createdAt || Date.now(),
            ping: Date.now(),
            active: true,
            memory: {
                usedJSHeapSize: performance?.memory?.usedJSHeapSize,
                totalJSHeapSize: performance?.memory?.totalJSHeapSize,
                jsHeapSizeLimit: performance?.memory?.jsHeapSizeLimit,
            },
            url: window.location.href,
        }
        window.document.title = TAB_INFO.id;
        update(tabs => {
            tabs[TAB_INFO.id] = TAB_INFO;
            return tabs;
        })
    }

    setInterval(save, 1000)

    window.onbeforeunload = () => {
        update(tabs => {
            delete tabs[TAB_INFO.id];
            return tabs
        })
    }

    setInterval(() => {
        let tabs = load();
        let list = Object.values(tabs);
        list.sort((a,b) => a.createdAt - b.createdAt);
        let staleTabs = list.filter(a => !a.active);

        // delete stale tabs marked in previous cycle
        if (staleTabs.length) {
            let staleTabIds = staleTabs.map(tab => tab.id).join(',');

            update(tabs => {
                staleTabs.forEach(tab => {
                    fetch(`/log?crashed=${tab.id}&url=${tab.url}&usedJSHeapSize=${tab.memory?.usedJSHeapSize}&totalJSHeapSize=${tab.memory?.totalJSHeapSize}`)
                    delete tabs[tab.id]
                })
                return tabs;
            })
        }

        let inactiveTabs = list.filter(a => Date.now() - a.ping > 5000);

        // mark as stale and to be deleted in the next cycle
        update(tabs => {
            inactiveTabs.forEach(tab => {
                if (tabs[tab.id]) {
                    tabs[tab.id].active = false;
                }
            })
            return tabs;
        })

        tabs = load();
        let params = Object.values(tabs).map(tab => {
            return `${tab.id}=${tab.active ? 'active' : 'inactive'}`
        }).join('&')
        fetch('/log?' + params)


        inactiveTabs.forEach(tab => {
            channel.postMessage({
                type: "inactive",
                id: tab.id
            })
        })

    }, 2000)

    function memoryCrash() {
        let dump = [];
        let dumps = {};

        setInterval(() => {
            for (let i = 0; i< 1000000; i++) {
                if (dump.length > 1000000) {
                    dumps[Object.keys(dumps).length] = dump;
                    dump = [];
                }
                dump.push(Math.random())
            }
        }, 1);
    }

    function freezeCrash() {
        while (true) {
            console.log("freeze")
        }
    }

</script>

<button onclick="memoryCrash()">memory crash</button>
<button onclick="freezeCrash()">freeze crash</button>