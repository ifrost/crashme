<script>
    let tabInfo = {
        id: Math.random().toString(36).slice(2, 7),
        createdAt: Date.now(),
        ping: Date.now(),
        stale: false,
        memory: {
            usedJSHeapSize: performance?.memory?.usedJSHeapSize,
            totalJSHeapSize: performance?.memory?.totalJSHeapSize,
            jsHeapSizeLimit: performance?.memory?.jsHeapSizeLimit,
        },
        url: window.location.href,
    }

    const tabs = {
        [tabInfo.id]: tabInfo
    };

    window.document.title = tabInfo.id

    const channel = new BroadcastChannel("crashme");

    window.onbeforeunload = () => {
        channel.postMessage({
            event: "close",
            tabInfo
        })
    }

    channel.onmessage = (event) => {
        if (event.data.event === 'ping') {
            tabs[event.data.tabInfo.id] = event.data.tabInfo;
        } else if (event.data.event === 'stale') {
            tabs[event.data.tabInfo.id] = event.data.tabInfo;
            if (event.data.tabInfo.id === tabInfo.id) {
                sendPing();
            }
        } else if (event.data.event === "close") {
            delete tabs[event.data.tabInfo.id]
        } else if (event.data.event === "delete") {
            delete tabs[event.data.tabInfo.id]
        }
    };

    function sendPing() {
        tabInfo.ping = Date.now();
        tabInfo.memory = {
            usedJSHeapSize: performance?.memory?.usedJSHeapSize,
            totalJSHeapSize: performance?.memory?.totalJSHeapSize,
            jsHeapSizeLimit: performance?.memory?.jsHeapSizeLimit,
        }
        tabInfo.url = window.location.href;
        channel.postMessage({
            event: "ping",
            tabInfo,
        });
    }

    setInterval(sendPing, 2000)

    setInterval(() => {
        let list = Object.values(tabs);
        list.sort((a,b) => a.createdAt - b.createdAt);

        let activeTabs = list.filter(a => Date.now() - a.ping < 3000);

        if (activeTabs.length) {
            const controller = activeTabs[0].id;
            window.document.title = tabInfo.id + ' (controller)'

            if (tabInfo.id === controller) {
                let staleTabs = list.filter(a => a.stale);

                if (staleTabs.length) {
                    staleTabs.forEach(tabInfo => {
                        newStaleTabs.forEach(tabInfo => {
                            channel.postMessage({
                                event: "delete",
                                tabInfo,
                            });
                        })
                        delete tabs[tabInfo.id];
                    })
                    console.log('Stale tabs deleted', staleTabs)
                    let ids = staleTabs.map(tab => tab.id);
                    fetch('/report?stale=' + ids);
                }

                let newStaleTabs = list.filter(a => Date.now() - a.ping > 10000);
                if (newStaleTabs.length) {
                    console.log('Stale/crashed tabs detected', newStaleTabs)
                    let ids = newStaleTabs.map(tab => tab.id);
                    fetch('/report?inactive=' + ids);
                    newStaleTabs.forEach(tabInfo => {
                        channel.postMessage({
                            event: "stale",
                            tabInfo,
                        });
                    })
                }
                window.localStorage.setItem('tabs', JSON.stringify(tabs));
            } else {
                window.document.title = tabInfo.id
            }
        } else {
            console.log("should not happen...")
        }
    }, 5000)


    function memoryCrash() {
        let dump = [];
        let dumps = {};

        setInterval(() => {
            for (let i = 0; i< 1000000; i++) {
                if (dump.length > 1000000) {
                    dumps[Object.keys(dumps).length] = dump;
                    dump = [];
                }
                dump.push(Math.random())
            }
        }, 1);
    }

    function recursiveCrash(v) {
        return recursiveCrash((v || 1) * Math.random())
    }

    function freezeCrash() {
        while (true) {
            console.log("freeze")
        }
    }

</script>

<button onclick="memoryCrash()">memory crash</button>
<button onclick="recursiveCrash()">recursive crash</button>
<button onclick="freezeCrash()">freeze crash</button>